##!/bin/bash

##  +-----------------------------------+-----------------------------------+
##  |                                                                       |
##  | Copyright (c) 2014-2019, https://github.com/andresgongora/synth-shell |
##  | Visit the above URL for details of license and authorship.            |
##  |                                                                       |
##  | This program is free software: you can redistribute it and/or modify  |
##  | it under the terms of the GNU General Public License as published by  |
##  | the Free Software Foundation, either version 3 of the License, or     |
##  | (at your option) any later version.                                   |
##  |                                                                       |
##  | This program is distributed in the hope that it will be useful,       |
##  | but WITHOUT ANY WARRANTY; without even the implied warranty of        |
##  | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         |
##  | GNU General Public License for more details.                          |
##  |                                                                       |
##  | You should have received a copy of the GNU General Public License     |
##  | along with this program. If not, see <http://www.gnu.org/licenses/>.  |
##  |                                                                       |
##  +-----------------------------------------------------------------------+
##
##
##  =======================
##  WARNING!!
##  DO NOT EDIT THIS FILE!!
##  =======================
##
##  This file was generated by an installation script.
##  If you edit this file, it might be overwritten without warning
##  and you will lose all your changes.
##
##  Visit for instructions and more information:
##  https://github.com/andresgongora/synth-shell/
##



loadConfigFile() {
	local config_file=$1
	if [ ! -f $config_file ]; then
		exit
	fi
	while IFS="" read -r p || [ -n "$p" ]
	do
		local line=$(echo "$p" |\
		             sed -e '/^$/d;
		                     /^[ \t]*\#/d;
		                     s/[ \t][ \t]*\#.*//g;
		                     s/^[ \t]*//g;
		                     s/[ \t]*$//g')
		local line_end_trimmed=$(echo "$line" | sed -n 's/[ \t]*\\$//p')
		if [ -z "$line_end_trimmed" ]; then
			local is_multiline_next=false
		else
			local is_multiline_next=true
			local line=$line_end_trimmed
		fi
		set -- $( echo "$line" | sed -e 's/\\//g;s/".*"/X/g' )
		if [ ! -z "$line" ] && [ "$#" -gt 1 ]; then
			local config_key_name=$1
			local config_param=$(echo "$line" |\
			                     sed -e "s/$config_key_name\s*//g" |\
			                     sed -e "s/^\"//g;s/\"$//g")
			eval config_key_current_value=\$$config_key_name
			if [ ! -z "$config_key_current_value" ]; then
				export "${config_key_name}"="$config_param"
			fi
		elif [ "$#" -eq 1 ] && $is_multiline ; then
			local line_end_trimmed=$(echo $line |\
			                         sed -n 's/[ \t]*\\$//p')
			if [ -z "$line_end_trimmed" ]; then
				local multi_line=false
			else
				echo ":) $line_end_trimmed"
				local multi_line=true
				local line=$line_end_trimmed
			fi
			local config_param_old=$config_param
			local config_param=$(echo "$line" |\
			                     sed "s/^\"//g;s/\"$//g")
			eval config_key_current_value=\$$config_key_name
			if [ ! -z "$config_key_current_value" ]; then
				export "${config_key_name}"="$config_key_current_value$config_param"
			fi
		fi
		local is_multiline=$is_multiline_next
	done < $config_file
}
get8bitCode()
{
	CODE=$1
	case $CODE in
		default)
			echo 9
			;;
		none)
			echo 9
			;;
		black)
			echo 0
			;;
		red)
			echo 1
			;;
		green)
			echo 2
			;;
		yellow)
			echo 3
			;;
		blue)
			echo 4
			;;
		magenta|purple|pink)
			echo 5
			;;
		cyan)
			echo 6
			;;
		light-gray)
			echo 7
			;;
		dark-gray)
			echo 60
			;;
		light-red)
			echo 61
			;;
		light-green)
			echo 62
			;;
		light-yellow)
			echo 63
			;;
		light-blue)
			echo 64
			;;
		light-magenta)
			echo 65
			;;
		light-cyan)
			echo 66
			;;
		white)
			echo 67
			;;
		*)
			echo 0
	esac
}
getColorCode()
{
	COLOR=$1
	if [ $COLOR -eq $COLOR ] 2> /dev/null; then
		if [ $COLOR -gt 0 -a $COLOR -lt 256 ]; then
			echo "38;5;$COLOR"
		else
			echo 0
		fi
	else
		BITCODE=$(get8bitCode $COLOR)
		COLORCODE=$(($BITCODE + 30))
		echo $COLORCODE
	fi
}
getBackgroundCode()
{
	COLOR=$1
	if [ $COLOR -eq $COLOR ] 2> /dev/null; then
		if [ $COLOR -gt 0 -a $COLOR -lt 256 ]; then
			echo "48;5;$COLOR"
		else
			echo 0
		fi
	else
		BITCODE=$(get8bitCode $COLOR)
		COLORCODE=$(($BITCODE + 40))
		echo $COLORCODE
	fi
}
getEffectCode()
{
	EFFECT=$1
	NONE=0
	case $EFFECT in
	none)
		echo $NONE
		;;
	default)
		echo $NONE
		;;
	bold)
		echo 1
		;;
	bright)
		echo 1
		;;
	dim)
		echo 2
		;;
	underline)
		echo 4
		;;
	blink)
		echo 5
		;;
	reverse)
		echo 7
		;;
	hidden)
		echo 8
		;;
	strikeout)
		echo 9
		;;
	*)
		echo $NONE
	esac
}
getFormattingSequence()
{
	START='\e[0;'
	MIDLE=$1
	END='m'
	echo -n "$START$MIDLE$END"
}
applyCodeToText()
{
	local RESET=$(getFormattingSequence $(getEffectCode none))
	TEXT=$1
	CODE=$2
	echo -n "$CODE$TEXT$RESET"
}
getFormatCode()
{
	local RESET=$(getFormattingSequence $(getEffectCode none))
	if [ "$#" -eq 0 ]; then
		echo -n "$RESET"
	elif [ "$#" -eq 1 ]; then
		TEXT_COLOR=$(getFormattingSequence $(getColorCode $1))
		echo -n "$TEXT_COLOR"
	else
		FORMAT=""
		while [ "$1" != "" ]; do
			TYPE=$1
			ARGUMENT=$2
			case $TYPE in
			-c)
				CODE=$(getColorCode $ARGUMENT)
				;;
			-b)
				CODE=$(getBackgroundCode $ARGUMENT)
				;;
			-e)
				CODE=$(getEffectCode $ARGUMENT)
				;;
			*)
				CODE=""
			esac
			if [ "$FORMAT" != "" ]; then
				FORMAT="$FORMAT;"
			fi
			FORMAT="$FORMAT$CODE"
			shift
			shift
		done
		FORMAT_CODE=$(getFormattingSequence $FORMAT)
		echo -n "${FORMAT_CODE}"
	fi
}
formatText()
{
	local RESET=$(getFormattingSequence $(getEffectCode none))
	if [ "$#" -eq 0 ]; then
		echo -n "${RESET}"
	elif [ "$#" -eq 1 ]; then
		TEXT=$1
		echo -n "${TEXT}${RESET}"
	else
		TEXT=$1
		FORMAT_CODE=$(getFormatCode "${@:2}")
		applyCodeToText "$TEXT" "$FORMAT_CODE"
	fi
}
removeColorCodes()
{
	printf "$1" | sed 's/\x1b\[[0-9;]*m//g'
}
shortenPath()
{
	local path=$1
	local max_length=$2
	local default_max_length=25
	local trunc_symbol=".."
	if   [ -z "$path" ]; then
		echo ""
		exit
	elif [ -z "$max_length" ]; then
		local max_length=$default_max_length
	fi
	local path=${path/#$HOME/\~}
	local dir=${path##*/}
	local dir_length=${#dir}
	local path_length=${#path}
	local print_length=$(( ( max_length < dir_length ) ? dir_length : max_length ))
	if [ $path_length -gt $print_length ]; then
		local offset=$(( $path_length - $print_length ))
		local truncated_path=${path:$offset}
		local clean_path=${truncated_path#*/}
		local short_path=${trunc_symbol}/${clean_path}
	else
		local short_path=$path
	fi
	echo $short_path
}
enableTerminalLineWrap()
{
	printf '\e[?7h'
}
disableTerminalLineWrap()
{
	printf '\e[?7l'
}
saveCursorPosition()
{
	printf "\e[s"
}
moveCursorToSavedPosition()
{
	printf "\e[u"
}
moveCursorToRowCol()
{
	local row=$1
	local col=$2
	printf "\e[${row};${col}H"
}
moveCursorHome()
{
	printf "\e[;H"
}
moveCursorUp()
{
	local inc=$1
	if   [ -z "$inc" ]; then
		printf "\e[1A"
	elif [ $inc -gt 0 ]; then
		printf "\e[${inc}A"
	fi
}
moveCursorDown()
{
	local inc=$1
	if   [ -z "$inc" ]; then
		printf "\e[1B"
	elif [ $inc -gt 0 ]; then
		printf "\e[${inc}B"
	fi
}
moveCursorLeft()
{
	local inc=$1
	if   [ -z "$inc" ]; then
		printf "\e[1C"
	elif [ $inc -gt 0 ]; then
		printf "\e[${inc}C"
	fi
}
moveCursorRight()
{
	local inc=$1
	if   [ -z "$inc" ]; then
		printf "\e[1D"
	elif [ $inc -gt 0 ]; then
		printf "\e[${inc}D"
	fi
}
getTerminalNumRows()
{
	tput lines
}
getTerminalNumCols()
{
	tput cols
}
getTextNumRows()
{
	local rows=$(echo -e "$1" | wc -l )
	echo "$rows"
}
getTextNumCols()
{
	local columns=$(echo -e "$1" | sed 's/\x1b\[[0-9;]*m//g' | wc -L )
	echo "$columns"
}
getTextShape()
{
	echo "$(getTextNumRows) $(getTextNumCols)"
}
printWithOffset()
{
	local row=$1
	local col=$2
	local text=${@:3}
	moveCursorDown "$row"
	if [ $col -gt 0 ]; then
		col_spacer="\\\\e[${col}C"
		local text=$(echo "$text" |\
		             sed "s/^/$col_spacer/g;s/\\\\n/\\\\n$col_spacer/g")
	fi
	disableTerminalLineWrap
	echo -e "${text}"
	enableTerminalLineWrap
}
printEmptyLines()
{
	local num_lines=$1
	if [ -n $num_lines ]; then
		while [ $num_lines -gt 0 ]; do
			echo ""
			((num_lines--))
		done
	fi
}
printTwoElementsSideBySide()
{
	local element_1=$1
	local element_2=$2
	local print_cols_max=$3
	local term_cols=$(getTerminalNumCols)
	if [ ! -z "$print_cols_max" ]; then
		local term_cols=$(( ( $term_cols > $print_cols_max ) ?\
			$print_cols_max : $term_cols ))
	fi
	local e_1_cols=$(getTextNumCols "$element_1")
	local e_1_rows=$(getTextNumRows "$element_1")
	local e_2_cols=$(getTextNumCols "$element_2")
	local e_2_rows=$(getTextNumRows "$element_2")
	local free_cols=$(( $term_cols - $e_1_cols - $e_2_cols ))
	if [ $e_1_cols -gt 0 ] && [ $e_2_cols -gt 0 ]; then
		local h_pad=$(( $free_cols/3 ))
		local e_1_h_pad=$h_pad
		local e_2_h_pad=$(( $e_1_cols + 2*$h_pad ))
	elif  [ $e_1_cols -gt 0 ]; then
		local h_pad=$(( $free_cols/2 ))
		local e_1_h_pad=$h_pad
		local e_2_h_pad=0
	elif  [ $e_2_cols -gt 0 ]; then
		local h_pad=$(( $free_cols/2 ))
		local e_1_h_pad=0
		local e_2_h_pad=$h_pad
	else
		local e_1_h_pad=0
		local e_2_h_pad=0
	fi
	local e_1_v_pad=$(( ( $e_1_rows > $e_2_rows ) ?\
		0 : (( ($e_2_rows - $e_1_rows)/2 )) ))
	local e_2_v_pad=$(( ( $e_2_rows > $e_1_rows ) ?\
		0 : (( ($e_1_rows - $e_2_rows)/2 )) ))
	local empty_v_pad=$(( ( $e_2_rows > $e_1_rows ) ?\
		$e_2_rows : $e_1_rows ))
	printEmptyLines $empty_v_pad
	moveCursorUp $empty_v_pad
	saveCursorPosition
	printWithOffset $e_1_v_pad $e_1_h_pad "$element_1"
	moveCursorToSavedPosition
	printWithOffset $e_2_v_pad $e_2_h_pad "$element_2"
	moveCursorToSavedPosition
	local max_rows=$(( ( $e_1_rows > $e_2_rows ) ? $e_1_rows : $e_2_rows ))
	moveCursorDown $(( $max_rows ))
}
fancy_bash_prompt()
{
getGitBranch()
{
	if ( which git > /dev/null 2>&1 ); then
		local branch=$(git branch 2> /dev/null |\
		             sed -n '/^[^*]/d;s/*\s*\(.*\)/\1/p')	
		if [[ -n "$branch" ]]; then
			local is_dirty=false &&\
				       [[ -n "$(git status --porcelain)" ]] &&\
				       is_dirty=true
			local is_ahead=false &&\
				       [[ "$(git status --porcelain -u no -b)" == *"ahead"* ]] &&\
				       is_ahead=true
			local is_behind=false &&\
				        [[ "$(git status --porcelain -u no -b)" == *"behind"* ]] &&\
				        is_behind=true
			if   $is_dirty && $is_ahead && $is_behind; then
				local symbol=$FBP_GIT_DIRTY_DIVERGED
			elif $is_dirty && $is_ahead; then
				local symbol=$FBP_GIT_DIRTY_AHEAD
			elif $is_dirty && $is_behind; then
				local symbol=$FBP_GIT_DIRTY_BEHIND
			elif $is_dirty; then
				local symbol=$FBP_GIT_DIRTY
			elif $is_ahead && $is_behind; then
				local symbol=$FBP_GIT_DIVERGED
			elif $is_ahead; then
				local symbol=$FBP_GIT_AHEAD
			elif $is_behind; then
				local symbol=$FBP_GIT_BEHIND
			else
				local symbol=$FBP_GIT_SYNCED
			fi
			echo "$branch $symbol"	
		fi
	fi
	echo ""
}
printSegment()
{
	local text=$1
	local font_color=$2
	local background_color=$3
	local next_background_color=$4
	local font_effect=$5
	if [ -z "$separator_char" ]; then local separator_char='\uE0B0'; fi
	local no_color="\[$(getFormatCode -e reset)\]"
	local text_format="\[$(getFormatCode -c $font_color -b $background_color -e $font_effect)\]"
	local separator_format="\[$(getFormatCode -c $background_color -b $next_background_color)\]"
	printf "${text_format}${text}${separator_format}${separator_char}${no_color}"
}
prompt_command_hook()
{
	if [ "$(type -t shortenPath)" != 'function' ];
	then
		local dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
		source "$dir/../bash-tools/bash-tools/shorten_path.sh"
	fi
	if [ "$(type -t removeColorCodes)" != 'function' ];
	then
		local dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
		source "$dir/../bash-tools/bash-tools/color.sh"
	fi
	local user=$USER
	local host=$HOSTNAME
	local path="$(shortenPath "$PWD" 20)"
	local git_branch="$(shortenPath "$(getGitBranch)" 10)"
	FBP_USER="$user"
	FBP_HOST="$host"
	FBP_PWD="$path"
	if [ -z "$git_branch" ]; then
		FBP_GIT=""
	else
		FBP_GIT="$git_branch"
	fi
	if [ ! -z "$(getGitBranch)" ] && $FBP_GIT_SHOW; then
		PS1=$FBP_PS1_GIT
	else
		PS1=$FBP_PS1
	fi
}
	local dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
	if [ "$(type -t getFormatCode)" != 'function' ]; then
		source "$dir/../bash-tools/bash-tools/color.sh"
	fi
	local font_color_user="white"
	local background_user="blue"
	local texteffect_user="bold"
	local font_color_host="white"
	local background_host="light-blue"
	local texteffect_host="bold"
	local font_color_pwd="dark-gray"
	local background_pwd="white"
	local texteffect_pwd="bold"
	local font_color_git="light-gray"
	local background_git="dark-gray"
	local texteffect_git="bold"
	local font_color_input="cyan"
	local background_input="none"
	local texteffect_input="bold"
	local separator_char='\uE0B0'
	local enable_vertical_padding=true
	local show_git=true
	local git_symbol_synced=''
	local git_symbol_unpushed='△'
	local git_symbol_unpulled='▽'
	local git_symbol_unpushedunpulled='○'
	local git_symbol_dirty='!'
	local git_symbol_dirty_unpushed='▲'
	local git_symbol_dirty_unpulled='▼'
	local git_symbol_dirty_unpushedunpulled='●'
	local user_config_file="$HOME/.config/synth-shell/fancy-bash-prompt.config"
	local sys_config_file="/etc/andresgongora/synth-shell/fancy-bash-prompt.config"
	if   [ -f $user_config_file ]; then
		source $user_config_file
	elif [ -f $sys_config_file ]; then
		source $sys_config_file
	fi
	local no_color="\[$(getFormatCode -e reset)\]"
	local ps1_input_format="\[$(getFormatCode       -c $font_color_input -b $background_input -e $texteffect_input)\]"
	local ps1_input="${ps1_input_format} "
	local ps1_user_git=$(printSegment " \${FBP_USER} " $font_color_user $background_user $background_host $texteffect_user)
	local ps1_host_git=$(printSegment " \${FBP_HOST} " $font_color_host $background_host $background_pwd $texteffect_host)
	local ps1_pwd_git=$(printSegment " \${FBP_PWD} " $font_color_pwd $background_pwd $background_git $texteffect_pwd)
	local ps1_git_git=$(printSegment " \${FBP_GIT} " $font_color_git $background_git $background_input $texteffect_git)
	local ps1_user=$(printSegment " \${FBP_USER} " $font_color_user $background_user $background_host $texteffect_user)
	local ps1_host=$(printSegment " \${FBP_HOST} " $font_color_host $background_host $background_pwd $texteffect_host)
	local ps1_pwd=$(printSegment " \${FBP_PWD} " $font_color_pwd $background_pwd $background_input $texteffect_pwd)
	local ps1_git=""
	FBP_GIT_SHOW=$show_git
	FBP_GIT_SYNCED=$git_symbol_synced
	FBP_GIT_AHEAD=$git_symbol_unpushed
	FBP_GIT_BEHIND=$git_symbol_unpulled
	FBP_GIT_DIVERGED=$git_symbol_unpushedunpulled
	FBP_GIT_DIRTY=$git_symbol_dirty
	FBP_GIT_DIRTY_AHEAD=$git_symbol_dirty_unpushed
	FBP_GIT_DIRTY_BEHIND=$git_symbol_dirty_unpulled
	FBP_GIT_DIRTY_DIVERGED=$git_symbol_dirty_unpushedunpulled
	if $enable_vertical_padding; then
		local vertical_padding="\n"
	else
		local vertical_padding=""
	fi
	case $TERM in
	xterm*|rxvt*)
		local titlebar="\[\033]0;\${FBP_USER}@\${FBP_HOST}: \${FBP_PWD}\007\]"
		;;
	*)
		local titlebar=""
		;;
	esac
	# FBP_PS1="${titlebar}${vertical_padding}${ps1_user}${ps1_host}${ps1_pwd}${ps1_git}${ps1_input}"
	FBP_PS1="${titlebar}${vertical_padding}${ps1_pwd}${ps1_git}${ps1_input}"
	# FBP_PS1_GIT="${titlebar}${vertical_padding}${ps1_user_git}${ps1_host_git}${ps1_pwd_git}${ps1_git_git}${ps1_input}"
	FBP_PS1_GIT="${titlebar}${vertical_padding}${ps1_pwd_git}${ps1_git_git}${ps1_input}"
	none="$(tput sgr0)"
	trap 'echo -ne "${none}"' DEBUG
	PROMPT_COMMAND=prompt_command_hook
}
if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	fancy_bash_prompt
	unset fancy_bash_prompt
fi
